# -*- coding: utf-8 -*-
"""Advanced.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZZViiL6RJCTh6tag_aZvJ2S_i-HLBAoW

We have connectivity into Globepay using their API. Our clients provide their credit and debit details within the our web application, our systems pass those credentials along with any relevant transaction details to Globepay for processing. We are experiencing a decline in the acceptance rate of credit and debit card payments processed by Globepay in the recent period. The “acceptance rate” is defined as the number of accepted transactions divided by the total attempted transactions.

Pra ir pro intermediario: converter tudo pra USD e dar percentuais de sucesso considerando a mudanca de moeda;
Plotar o grafico das transacoes accepted vs rejected per month
"""

#Importing libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime
import seaborn as sns
import json
from sklearn.preprocessing import StandardScaler

#Creating datasets with the CSV 
db1 = pd.read_csv("Globepay Acceptance Report - Globepay Acceptance Report.csv")
db2 = pd.read_csv("Globepay Chargeback Report - Globepay Chargeback Report.csv")
db1.head()

db1['date_time'] =  pd.to_datetime(db1['date_time'], infer_datetime_format=True)
db1['date_time_month'] = db1.date_time.dt.to_period('M')

# Joining tables to make sure analysis is complete
data = pd.merge(db1, db2, on='external_ref', how='left', suffixes=('_db1', '_db2'), validate='one_to_one')
data.head()

########### DROPPING SINGLE NEGATIVE
data = data[data.amount > 0]

#Calculating acceptance transactions
counts = data["state"].value_counts()
counts

#Calculating ratio acceptance
ratio_acceptance = (3777/5430)
ratio_acceptance

#Calculating chargebacked transactions
counts_c = data["chargeback"].value_counts()
counts_c

"""The acceptance rate of transactions is around 69,5%.  Charging back a transaction means asking for funds on a previous accepted transaction - Less than 5% of total of transactions was chargedback. We can safely infer that transactions that were chargedback don't have impact on the acceptance rate. Considering the sample is small, I will skip further analysis on chargebacks for now. A potential area to explore would be checking if any of the chargebacked transactions had a previous failed one - this could be something to raise with the card partner."""

##Plotting data to find patterns
##Plotting by currency
data.currency.value_counts(normalize=True).plot.bar(color='black');

"""We can see from the sample that most of the transactions are performed in USD, so let's bring all transactions to USD to analyse the full sample."""

def amount_in_usd(row):
    if row.currency == "USD":
        return row.amount
    
    rates = json.loads(row.rates)
    usd_to_origin = rates[row.currency]
    return row.amount / usd_to_origin

## converting to USD 
data["amount_in_usd"] = data.apply(amount_in_usd, axis=1)
data[3:10].head()

sns.barplot(data=data.groupby(['date_time_month', 'state'])['external_ref'].count().reset_index(),
            x="date_time_month", y="external_ref", hue="state")

#Calculating country vs. currencies transactions
int_payments_x = data.groupby(['state','country','currency', ])['external_ref'].count()

int_payments_x

#Calculating cvv_provided transactions per country and currency
int_payments = data.groupby(['state','country','currency', 'cvv_provided'])['external_ref'].count()

int_payments

"""1.   There is a higher volume of transactions in USD that are not initiated in the US, indicating a volume of international payments. Most of these payments are from the AE and they represent a fairly higher failure rate.
2.   There are 1653 transactions declined in total from which 1638 also don't provide the CVV code. With more than 99% of the failed transactions not having a CVV code associated one could easily assume that it is what is driving the acceptance ratio down.

International payments originated from AE in USD are the main rejected payments. However, only in France and United States we have payments declined **while** the cvv code was provided. Considering the most common API calls associated to card failure (using [Stripe](https://stripe.com/docs/declines) documentation as reference) and without any information on the failure reason codes for this sample, we can only infer that in 4 out of 6 countries all the failed transactions are linked to not providing a CVV code while doing the purchase. 

This represents more than 50% of the sample.

# But, we still have a significant amount of transactions ACCEPTED without providing the CVV code.
*How can that be the reason affecting the acceptance rate?*

According to Visa and MasterCard:

```
CVV requirements pertain mainly to one-off, non-stored credit card transactions. 

There are many transaction types that do not require CVV, which we’ve listed below:

3D Secure-verified transactions
Payment token transactions, which include the following payment_ instrument _ types:
android_ pay_ card
apple_ pay_ card
masterpass_ card
paypal_ account
venmo_ account
visa_ checkout_card
Authorization adjustments
Recurring transactions
```

By the context given:
```
"We have partnered with Globepay to process all of these account funding credit and debit card transactions"
```
We can get to the following conclusions:


1.   With the dataset provided, it is **not** possible to understand if the payments in question are first-time payments from these customers, if they have 3DS checks or have been performed using any external wallet. We would need a sample showing a bigger time period or having a column stating if it is their first payment or not.
2.   We do **not** have the failure reason codes to rule out that the reason of failure is not related to not providing a CVV code while making the purchase.
3. We do **not** have any way of ruling out that the accepted payments without a CVV code are not recurring payments from existent customers.
4. Assuming that the main failure reason is the lack of CVV code, it is then possible.

#The rootcause of this issue lays on the fact that the process of submitting payments doesn't have a mechanism to understand if a CVV code should be requested according to the method used by the customer and adapting the UI to do so. GlobalPay is treating all card processements requests as the same, and when a customer is doing their first purchase or not using a digital wallet the CVV (which is a layer of verification when the card is not present) is not required.

These failure could be avoided one or two of the following actions:


*   Contacting GlobalPay to ask them to redirect new customers to a new screen of payment that mandatory will include a field to enter the CVV code;
*   Contacting GlobalPay to ask them to include on the failure report the codes of failure reasons to validate the hypotesis;
*   Syncing with internal design and product team to make sure we educate our customers about how payments will be taken e.g first time we require more details from you, including your CVV code, and on the next ones you will spared. Or you can actually use other payments methods as GooglePay or Apple Pay to avoid this even on your first payment.
*   Considering not using an external provider anymore to process payments and bringing the whole process inside the house - making the customer experience smoother and also having more data to make analysis on failure rates, chargebacks, FX rates and others.


According to the existent roadmap and the terms of the partnership with GlobalPay a proper action should be instated immediatelly.

## And if this get sorted - what could be a reason for not having completed card transactions?

Then, we could come back and look the data for more insights. Building a training ML model we can see what could be the potential second cause of having completed transactions.
"""

train = data[["state", "cvv_provided", "country", "currency", "chargeback", "amount_in_usd"]]

train.columns

##training pattern to assume that transactions would be ACCEPTED (not failing CVV check)
train.state = train.state == "ACCEPTED"

train.amount_in_usd = np.log(train.amount_in_usd)
train.amount_in_usd= StandardScaler().fit_transform(train.amount_in_usd.values.reshape(-1, 1)).reshape(-1)

train

train.columns

from sklearn.linear_model import LogisticRegression
from sklearn.feature_selection import RFE

cols = ['cvv_provided', 'chargeback', 'amount_in_usd', 'country_AE',
       'country_CA', 'country_FR', 'country_MX', 'country_UK', 'country_US',
       'currency_CAD', 'currency_EUR', 'currency_GBP', 'currency_MXN',
       'currency_USD']

X = train[cols].values
y = train['state']

model = LogisticRegression()
model = model.fit(X, y)

coef = list(np.absolute(model.coef_).reshape(-1))

coef_map = dict(zip(cols, coef))
coef_map

currencies = ["CAD", "EUR", "GBP", "MXN", "USD"]
countries = ["AE", "CA", "FR", "MX", "UK", "US"]

coef_map["currency"] = 0
for c in currencies:
    coef_map["currency"] += coef_map["currency_" + c]
    del coef_map["currency_" + c]
    
coef_map["country"] = 0
for c in countries:
    coef_map["country"] += coef_map["country_" + c]
    del coef_map["country_" + c]
    
coef_map

coef_map.values()

sns.barplot(x=list(coef_map.keys()), y=list(coef_map.values()))

"""Considering the sample provided of accepted transactions after sorting the CVV issue highlight earlier, it would be most likely to start working on avoiding chargebacks to guarantee the acceptance rate."""